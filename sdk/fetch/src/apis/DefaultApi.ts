/* tslint:disable */
/* eslint-disable */
/**
 * mira API
 * API for Project-Mira
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BatchGetMainItemByIdListResult,
  BatchGetSubItemByIdListResult,
  ClientMapping,
  CreateSubItemFavoriteRequestBody,
  DeleteClientMappingByMainItemResponse,
  Favorite,
  FavoriteProgress,
  GetOnAirItemListResponse,
  IdListRequestBody,
  ListFavoritesResponse,
  ListMainItemResponse,
  ListSubItemFavoriteResponse,
  MainItem,
  PatchFavoriteBody,
  SubItem,
  SubItemFavorite,
  SucceedEmptyResponse,
} from '../models/index';

export interface AddClientMappingRequest {
    request_body: Array<string>;
}

export interface BatchGetMainItemByIdListRequest {
    IdListRequestBody: IdListRequestBody;
}

export interface BatchGetSubItemsByIdListRequest {
    IdListRequestBody: IdListRequestBody;
}

export interface CreateFavoriteRequest {
    Favorite: Omit<Favorite, 'id'>;
}

export interface CreateSubItemFavoriteRequest {
    CreateSubItemFavoriteRequestBody: CreateSubItemFavoriteRequestBody;
}

export interface DeleteClientMappingByMainItemIdRequest {
    id: string;
}

export interface DeleteFavoriteRequest {
    id: string;
}

export interface DeleteSubItemFavoriteRequest {
    id: string;
}

export interface GetFavoriteByMainItemIdRequest {
    id: string;
}

export interface GetFavoriteProgressByMainItemIdRequest {
    mainItemId: string;
    epType: number;
}

export interface GetMainItemByIdRequest {
    id: string;
    coverImage?: string;
    subItems?: string;
}

export interface GetSubItemByIdRequest {
    id: string;
}

export interface ListFavoritesRequest {
    status: string;
    offset?: number;
    limit?: number;
    orderBy?: string;
    sort?: string;
}

export interface ListMainItemsRequest {
    serviceClientId?: string;
    mainType?: string;
    type?: string;
    subType?: string;
    offset?: number;
    limit?: number;
    orderBy?: string;
    sort?: string;
    keyword?: string;
}

export interface ListSubItemFavoritesRequest {
    itemId?: string;
    offset?: number;
    limit?: number;
    orderBy?: string;
    sort?: string;
    subItem?: boolean;
}

export interface OnAirItemRequest {
    type: string;
}

export interface PatchFavoriteRequest {
    id: string;
    PatchFavoriteBody: PatchFavoriteBody;
}

export interface PredictMainItemNameRequest {
    prefix: string;
}

export interface UpdateFavoriteProgressRequest {
    mainItemId: string;
    progress: number;
    epType: number;
}

/**
 * DefaultApi - interface
 * 
 * @export
 * @interface DefaultApiInterface
 */
export interface DefaultApiInterface {
    /**
     * Add ClientMapping
     * @param {Array<string>} request_body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    addClientMappingRaw(requestParameters: AddClientMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClientMapping>>;

    /**
     * Add ClientMapping
     */
    addClientMapping(requestParameters: AddClientMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClientMapping>;

    /**
     * get mainItems by id list
     * @param {IdListRequestBody} IdListRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    batchGetMainItemByIdListRaw(requestParameters: BatchGetMainItemByIdListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BatchGetMainItemByIdListResult>>;

    /**
     * get mainItems by id list
     */
    batchGetMainItemByIdList(requestParameters: BatchGetMainItemByIdListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchGetMainItemByIdListResult>;

    /**
     * get SubItems by id list
     * @param {IdListRequestBody} IdListRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    batchGetSubItemsByIdListRaw(requestParameters: BatchGetSubItemsByIdListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BatchGetSubItemByIdListResult>>;

    /**
     * get SubItems by id list
     */
    batchGetSubItemsByIdList(requestParameters: BatchGetSubItemsByIdListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchGetSubItemByIdListResult>;

    /**
     * create a favorite for user and item
     * @param {Favorite} Favorite 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    createFavoriteRaw(requestParameters: CreateFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Favorite>>;

    /**
     * create a favorite for user and item
     */
    createFavorite(requestParameters: CreateFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Favorite>;

    /**
     * create a SubItemFavorite
     * @param {CreateSubItemFavoriteRequestBody} CreateSubItemFavoriteRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    createSubItemFavoriteRaw(requestParameters: CreateSubItemFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubItemFavorite>>;

    /**
     * create a SubItemFavorite
     */
    createSubItemFavorite(requestParameters: CreateSubItemFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubItemFavorite>;

    /**
     * Delete ClientMapping by MainItem id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteClientMappingByMainItemIdRaw(requestParameters: DeleteClientMappingByMainItemIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteClientMappingByMainItemResponse>>;

    /**
     * Delete ClientMapping by MainItem id
     */
    deleteClientMappingByMainItemId(requestParameters: DeleteClientMappingByMainItemIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteClientMappingByMainItemResponse>;

    /**
     * Delete a favorite
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteFavoriteRaw(requestParameters: DeleteFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SucceedEmptyResponse>>;

    /**
     * Delete a favorite
     */
    deleteFavorite(requestParameters: DeleteFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SucceedEmptyResponse>;

    /**
     * Delete a SubItemFavorite
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteSubItemFavoriteRaw(requestParameters: DeleteSubItemFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SucceedEmptyResponse>>;

    /**
     * Delete a SubItemFavorite
     */
    deleteSubItemFavorite(requestParameters: DeleteSubItemFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SucceedEmptyResponse>;

    /**
     * get favorite by MainItem id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getFavoriteByMainItemIdRaw(requestParameters: GetFavoriteByMainItemIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Favorite>>;

    /**
     * get favorite by MainItem id
     */
    getFavoriteByMainItemId(requestParameters: GetFavoriteByMainItemIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Favorite>;

    /**
     * get favorite progress (number of SubItemFavorite from the beginning) of a episode type for mainItem
     * @param {string} mainItemId 
     * @param {number} epType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getFavoriteProgressByMainItemIdRaw(requestParameters: GetFavoriteProgressByMainItemIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FavoriteProgress>>;

    /**
     * get favorite progress (number of SubItemFavorite from the beginning) of a episode type for mainItem
     */
    getFavoriteProgressByMainItemId(requestParameters: GetFavoriteProgressByMainItemIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FavoriteProgress>;

    /**
     * get a MainItem by id
     * @param {string} id MainItem id
     * @param {string} [coverImage] populate coverImage if true
     * @param {string} [subItems] populate subItems if true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getMainItemByIdRaw(requestParameters: GetMainItemByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MainItem>>;

    /**
     * get a MainItem by id
     */
    getMainItemById(requestParameters: GetMainItemByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MainItem>;

    /**
     * get a SubItem by id
     * @param {string} id SubItem Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getSubItemByIdRaw(requestParameters: GetSubItemByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubItem>>;

    /**
     * get a SubItem by id
     */
    getSubItemById(requestParameters: GetSubItemByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubItem>;

    /**
     * list favorites for user
     * @param {string} status 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listFavoritesRaw(requestParameters: ListFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListFavoritesResponse>>;

    /**
     * list favorites for user
     */
    listFavorites(requestParameters: ListFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListFavoritesResponse>;

    /**
     * list MainItems
     * @param {string} [serviceClientId] 
     * @param {string} [mainType] 
     * @param {string} [type] 
     * @param {string} [subType] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {string} [sort] 
     * @param {string} [keyword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listMainItemsRaw(requestParameters: ListMainItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListMainItemResponse>>;

    /**
     * list MainItems
     */
    listMainItems(requestParameters: ListMainItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListMainItemResponse>;

    /**
     * list SubItemFavorite
     * @param {string} [itemId] itemId of the SubItem, if provided then other parameters are ignored
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [orderBy] 
     * @param {string} [sort] 
     * @param {boolean} [subItem] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    listSubItemFavoritesRaw(requestParameters: ListSubItemFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListSubItemFavoriteResponse>>;

    /**
     * list SubItemFavorite
     */
    listSubItemFavorites(requestParameters: ListSubItemFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListSubItemFavoriteResponse>;

    /**
     * get a list of on air MainItems with cover image
     * @param {string} type type of MainItem, must be either anime or real
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    onAirItemRaw(requestParameters: OnAirItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetOnAirItemListResponse>>;

    /**
     * get a list of on air MainItems with cover image
     */
    onAirItem(requestParameters: OnAirItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetOnAirItemListResponse>;

    /**
     * change status of a favorite
     * @param {string} id 
     * @param {PatchFavoriteBody} PatchFavoriteBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchFavoriteRaw(requestParameters: PatchFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SucceedEmptyResponse>>;

    /**
     * change status of a favorite
     */
    patchFavorite(requestParameters: PatchFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SucceedEmptyResponse>;

    /**
     * predict Main Item names base on provided prefix
     * @param {string} prefix start part of the name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    predictMainItemNameRaw(requestParameters: PredictMainItemNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>>;

    /**
     * predict Main Item names base on provided prefix
     */
    predictMainItemName(requestParameters: PredictMainItemNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>>;

    /**
     * update progress of a favorite, will create/delete SubItemFavorite
     * @param {string} mainItemId 
     * @param {number} progress 
     * @param {number} epType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    updateFavoriteProgressRaw(requestParameters: UpdateFavoriteProgressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SucceedEmptyResponse>>;

    /**
     * update progress of a favorite, will create/delete SubItemFavorite
     */
    updateFavoriteProgress(requestParameters: UpdateFavoriteProgressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SucceedEmptyResponse>;

}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI implements DefaultApiInterface {

    /**
     * Add ClientMapping
     */
    async addClientMappingRaw(requestParameters: AddClientMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClientMapping>> {
        if (requestParameters['request_body'] == null) {
            throw new runtime.RequiredError(
                'request_body',
                'Required parameter "request_body" was null or undefined when calling addClientMapping().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/client-mapping`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['request_body'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Add ClientMapping
     */
    async addClientMapping(requestParameters: AddClientMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClientMapping> {
        const response = await this.addClientMappingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get mainItems by id list
     */
    async batchGetMainItemByIdListRaw(requestParameters: BatchGetMainItemByIdListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BatchGetMainItemByIdListResult>> {
        if (requestParameters['IdListRequestBody'] == null) {
            throw new runtime.RequiredError(
                'IdListRequestBody',
                'Required parameter "IdListRequestBody" was null or undefined when calling batchGetMainItemByIdList().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/client-mapping/batch/main`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['IdListRequestBody'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * get mainItems by id list
     */
    async batchGetMainItemByIdList(requestParameters: BatchGetMainItemByIdListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchGetMainItemByIdListResult> {
        const response = await this.batchGetMainItemByIdListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get SubItems by id list
     */
    async batchGetSubItemsByIdListRaw(requestParameters: BatchGetSubItemsByIdListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BatchGetSubItemByIdListResult>> {
        if (requestParameters['IdListRequestBody'] == null) {
            throw new runtime.RequiredError(
                'IdListRequestBody',
                'Required parameter "IdListRequestBody" was null or undefined when calling batchGetSubItemsByIdList().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/client-mapping/batch/subItem`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['IdListRequestBody'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * get SubItems by id list
     */
    async batchGetSubItemsByIdList(requestParameters: BatchGetSubItemsByIdListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchGetSubItemByIdListResult> {
        const response = await this.batchGetSubItemsByIdListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a favorite for user and item
     */
    async createFavoriteRaw(requestParameters: CreateFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Favorite>> {
        if (requestParameters['Favorite'] == null) {
            throw new runtime.RequiredError(
                'Favorite',
                'Required parameter "Favorite" was null or undefined when calling createFavorite().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/favorite`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['Favorite'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * create a favorite for user and item
     */
    async createFavorite(requestParameters: CreateFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Favorite> {
        const response = await this.createFavoriteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * create a SubItemFavorite
     */
    async createSubItemFavoriteRaw(requestParameters: CreateSubItemFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubItemFavorite>> {
        if (requestParameters['CreateSubItemFavoriteRequestBody'] == null) {
            throw new runtime.RequiredError(
                'CreateSubItemFavoriteRequestBody',
                'Required parameter "CreateSubItemFavoriteRequestBody" was null or undefined when calling createSubItemFavorite().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/favorite/sub`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['CreateSubItemFavoriteRequestBody'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * create a SubItemFavorite
     */
    async createSubItemFavorite(requestParameters: CreateSubItemFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubItemFavorite> {
        const response = await this.createSubItemFavoriteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete ClientMapping by MainItem id
     */
    async deleteClientMappingByMainItemIdRaw(requestParameters: DeleteClientMappingByMainItemIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteClientMappingByMainItemResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteClientMappingByMainItemId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/client-mapping/main/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Delete ClientMapping by MainItem id
     */
    async deleteClientMappingByMainItemId(requestParameters: DeleteClientMappingByMainItemIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteClientMappingByMainItemResponse> {
        const response = await this.deleteClientMappingByMainItemIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a favorite
     */
    async deleteFavoriteRaw(requestParameters: DeleteFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SucceedEmptyResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteFavorite().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/favorite/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Delete a favorite
     */
    async deleteFavorite(requestParameters: DeleteFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SucceedEmptyResponse> {
        const response = await this.deleteFavoriteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a SubItemFavorite
     */
    async deleteSubItemFavoriteRaw(requestParameters: DeleteSubItemFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SucceedEmptyResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteSubItemFavorite().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/favorite/sub/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Delete a SubItemFavorite
     */
    async deleteSubItemFavorite(requestParameters: DeleteSubItemFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SucceedEmptyResponse> {
        const response = await this.deleteSubItemFavoriteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get favorite by MainItem id
     */
    async getFavoriteByMainItemIdRaw(requestParameters: GetFavoriteByMainItemIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Favorite>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getFavoriteByMainItemId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/favorite/main/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * get favorite by MainItem id
     */
    async getFavoriteByMainItemId(requestParameters: GetFavoriteByMainItemIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Favorite> {
        const response = await this.getFavoriteByMainItemIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get favorite progress (number of SubItemFavorite from the beginning) of a episode type for mainItem
     */
    async getFavoriteProgressByMainItemIdRaw(requestParameters: GetFavoriteProgressByMainItemIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FavoriteProgress>> {
        if (requestParameters['mainItemId'] == null) {
            throw new runtime.RequiredError(
                'mainItemId',
                'Required parameter "mainItemId" was null or undefined when calling getFavoriteProgressByMainItemId().'
            );
        }

        if (requestParameters['epType'] == null) {
            throw new runtime.RequiredError(
                'epType',
                'Required parameter "epType" was null or undefined when calling getFavoriteProgressByMainItemId().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['mainItemId'] != null) {
            queryParameters['mainItemId'] = requestParameters['mainItemId'];
        }

        if (requestParameters['epType'] != null) {
            queryParameters['epType'] = requestParameters['epType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/favorite/progress`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * get favorite progress (number of SubItemFavorite from the beginning) of a episode type for mainItem
     */
    async getFavoriteProgressByMainItemId(requestParameters: GetFavoriteProgressByMainItemIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FavoriteProgress> {
        const response = await this.getFavoriteProgressByMainItemIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a MainItem by id
     */
    async getMainItemByIdRaw(requestParameters: GetMainItemByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MainItem>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getMainItemById().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['coverImage'] != null) {
            queryParameters['coverImage'] = requestParameters['coverImage'];
        }

        if (requestParameters['subItems'] != null) {
            queryParameters['subItems'] = requestParameters['subItems'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/public/item/main/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * get a MainItem by id
     */
    async getMainItemById(requestParameters: GetMainItemByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MainItem> {
        const response = await this.getMainItemByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a SubItem by id
     */
    async getSubItemByIdRaw(requestParameters: GetSubItemByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubItem>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getSubItemById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/public/item/main/subItem/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * get a SubItem by id
     */
    async getSubItemById(requestParameters: GetSubItemByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubItem> {
        const response = await this.getSubItemByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list favorites for user
     */
    async listFavoritesRaw(requestParameters: ListFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListFavoritesResponse>> {
        if (requestParameters['status'] == null) {
            throw new runtime.RequiredError(
                'status',
                'Required parameter "status" was null or undefined when calling listFavorites().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orderBy'] != null) {
            queryParameters['orderBy'] = requestParameters['orderBy'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/favorite`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * list favorites for user
     */
    async listFavorites(requestParameters: ListFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListFavoritesResponse> {
        const response = await this.listFavoritesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list MainItems
     */
    async listMainItemsRaw(requestParameters: ListMainItemsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListMainItemResponse>> {
        const queryParameters: any = {};

        if (requestParameters['serviceClientId'] != null) {
            queryParameters['serviceClientId'] = requestParameters['serviceClientId'];
        }

        if (requestParameters['mainType'] != null) {
            queryParameters['mainType'] = requestParameters['mainType'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['subType'] != null) {
            queryParameters['subType'] = requestParameters['subType'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orderBy'] != null) {
            queryParameters['orderBy'] = requestParameters['orderBy'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['keyword'] != null) {
            queryParameters['keyword'] = requestParameters['keyword'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/public/item/main`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * list MainItems
     */
    async listMainItems(requestParameters: ListMainItemsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListMainItemResponse> {
        const response = await this.listMainItemsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * list SubItemFavorite
     */
    async listSubItemFavoritesRaw(requestParameters: ListSubItemFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListSubItemFavoriteResponse>> {
        const queryParameters: any = {};

        if (requestParameters['itemId'] != null) {
            queryParameters['itemId'] = requestParameters['itemId'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orderBy'] != null) {
            queryParameters['orderBy'] = requestParameters['orderBy'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['subItem'] != null) {
            queryParameters['subItem'] = requestParameters['subItem'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/favorite/sub`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * list SubItemFavorite
     */
    async listSubItemFavorites(requestParameters: ListSubItemFavoritesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListSubItemFavoriteResponse> {
        const response = await this.listSubItemFavoritesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a list of on air MainItems with cover image
     */
    async onAirItemRaw(requestParameters: OnAirItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetOnAirItemListResponse>> {
        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling onAirItem().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/public/item/on-air`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * get a list of on air MainItems with cover image
     */
    async onAirItem(requestParameters: OnAirItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetOnAirItemListResponse> {
        const response = await this.onAirItemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * change status of a favorite
     */
    async patchFavoriteRaw(requestParameters: PatchFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SucceedEmptyResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling patchFavorite().'
            );
        }

        if (requestParameters['PatchFavoriteBody'] == null) {
            throw new runtime.RequiredError(
                'PatchFavoriteBody',
                'Required parameter "PatchFavoriteBody" was null or undefined when calling patchFavorite().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/favorite/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['PatchFavoriteBody'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * change status of a favorite
     */
    async patchFavorite(requestParameters: PatchFavoriteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SucceedEmptyResponse> {
        const response = await this.patchFavoriteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * predict Main Item names base on provided prefix
     */
    async predictMainItemNameRaw(requestParameters: PredictMainItemNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters['prefix'] == null) {
            throw new runtime.RequiredError(
                'prefix',
                'Required parameter "prefix" was null or undefined when calling predictMainItemName().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['prefix'] != null) {
            queryParameters['prefix'] = requestParameters['prefix'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/public/item/predict`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * predict Main Item names base on provided prefix
     */
    async predictMainItemName(requestParameters: PredictMainItemNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.predictMainItemNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * update progress of a favorite, will create/delete SubItemFavorite
     */
    async updateFavoriteProgressRaw(requestParameters: UpdateFavoriteProgressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SucceedEmptyResponse>> {
        if (requestParameters['mainItemId'] == null) {
            throw new runtime.RequiredError(
                'mainItemId',
                'Required parameter "mainItemId" was null or undefined when calling updateFavoriteProgress().'
            );
        }

        if (requestParameters['progress'] == null) {
            throw new runtime.RequiredError(
                'progress',
                'Required parameter "progress" was null or undefined when calling updateFavoriteProgress().'
            );
        }

        if (requestParameters['epType'] == null) {
            throw new runtime.RequiredError(
                'epType',
                'Required parameter "epType" was null or undefined when calling updateFavoriteProgress().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['mainItemId'] != null) {
            queryParameters['mainItemId'] = requestParameters['mainItemId'];
        }

        if (requestParameters['progress'] != null) {
            queryParameters['progress'] = requestParameters['progress'];
        }

        if (requestParameters['epType'] != null) {
            queryParameters['epType'] = requestParameters['epType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuth2", ["bookmark"]);
        }

        const response = await this.request({
            path: `/favorite/progress`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * update progress of a favorite, will create/delete SubItemFavorite
     */
    async updateFavoriteProgress(requestParameters: UpdateFavoriteProgressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SucceedEmptyResponse> {
        const response = await this.updateFavoriteProgressRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
